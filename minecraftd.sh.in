#!/bin/bash

# The actual program name (name of the interface)
declare -r INAME="@INAME@"
declare -r GAME="@GAME@"
declare -r LIBRARY_PATH="@LIBRARY_PATH@"

test -r "$LIBRARY_PATH/argparse.sh" || (echo "Cannot find argparse.sh in $LIBRARY_PATH" >&2; exit 1)

# Note: this calls "set -u" to disallow the use of uninitialized variables.
source "$LIBRARY_PATH/argparse.sh"

DESCRIPTION="This script was designed to easily control any ${GAME} server. Almost\n"
DESCRIPTION+="any parameter for a given	${GAME} server derivative can be changed by\n"
DESCRIPTION+="editing the variables in the configuration file."

COPYRIGHT="Report bugs to <https://github.com/Edenhofer/minecraft-server>.\n"
COPYRIGHT+="Copyright (c) Gordian Edenhofer <gordian.edenhofer@gmail.com>\n"
COPYRIGHT+="and contributors (see: https://github.com/Edenhofer/minecraft-server/graphs/contributors)\n"
COPYRIGHT+="\n"
COPYRIGHT+="This program is free software; you can redistribute it and/or\n"
COPYRIGHT+="modify it under the terms of the GNU General Public License\n"
COPYRIGHT+="as published by the Free Software Foundation; either version 2\n"
COPYRIGHT+="of the License, or (at your option) any later version.\n"
COPYRIGHT+="\n"
COPYRIGHT+="For details, see: https://github.com/Edenhofer/minecraft-server#license"

add_subcommand start "Start the server instance."
add_subcommand stop "Stop the server instance."
add_subcommand status "Check status of a running server instance."
add_subcommand restart "Restart the server instance."
add_subcommand console "Attach to the server console. Press Ctrl+B and then Ctrl+D to detach (by default; your tmux settings may be different)."
add_subcommand command "Run a command on the server console and report the result."
add_subcommand backup "Immediately take a backup of the server. Backups are written to the directory specified in the BACKUP_DEST configuration variable."
add_subcommand restore "Restore a server backup from an archive file."
add_subcommand print "Print a variable from the configuration."
add_subcommand init "Create directories for the server."
add_subcommand idle_server_daemon "Internal use only"

add_arg i instance SERVER_INSTANCE "Server instance. Multiple instances of @GAME@ can run concurrently. If omitted, the default instance is used." false
add_arg c command command:SERVER_COMMAND "Command to run" true
add_arg a archive restore:ARCHIVE_PATH "Path to the backup archive to restore." true
add_arg k key print:CONFIG_VAR "Configuration variable to print (SERVER_ROOT, SESSION_NAME, etc.). If omitted, prints the entire configuration." false

parse_args "$@"

# General rule for the variable-naming-schema:
# Variables in capital letters may be passed through the command line others not.
# Avoid altering any of those later in the code since they may be readonly (IDLE_SERVER is an exception!)

# You may use this script for any game server of your choice, just alter the config file
declare -A default_config
default_config[SESSION_NAME]="@SESSION_NAME@"
default_config[SERVER_ROOT]="@SERVER_ROOT@"
default_config[CONFIG_PATH]="@CONFIG_PATH@"
default_config[INSTANCE_CONFIG_DIR]="@INSTANCE_CONFIG_DIR@"
default_config[BACKUP_DEST]="@BACKUP_DEST@"
default_config[BACKUP_PATHS]="@BACKUP_PATHS@"
default_config[BACKUP_FLAGS]="@BACKUP_FLAGS@"
default_config[KEEP_BACKUPS]="@KEEP_BACKUPS@"
default_config[GAME_USER]="@GAME_USER@"
default_config[MAIN_EXECUTABLE]="@MAIN_EXECUTABLE_ABSOLUTE@"
default_config[SESSION_NAME]="@SESSION_NAME@"

# Command and parameter declaration with which to start the server
default_config[SERVER_MEMORY_INITIAL]="@SERVER_MEMORY_INITIAL@"
default_config[SERVER_MEMORY_MAXIMUM]="@SERVER_MEMORY_MAXIMUM@"
default_config[SERVER_START_CMD]="@SERVER_START_CMD@"
default_config[SERVER_START_SUCCESS]="@SERVER_START_SUCCESS@"

# System parameters for the control script
default_config[IDLE_SERVER]="@IDLE_SERVER@"
default_config[IDLE_SESSION_NAME]="@IDLE_SESSION_NAME@"
default_config[GAME_PORT]="@GAME_PORT@"
default_config[CHECK_PLAYER_TIME]="@CHECK_PLAYER_TIME@"
default_config[IDLE_IF_TIME]="@IDLE_IF_TIME@"

# Additional configuration options which only few may need to alter
default_config[GAME_COMMAND_DUMP]="@GAME_COMMAND_DUMP@"

# Variables whose defaults get overridden in instantiated mode. %i is substituted with the instance name.
declare -A instance_config
instance_config[SESSION_NAME]="@GAME@-%i"
instance_config[SERVER_ROOT]="@SERVER_ROOT@/servers/%i"
instance_config[BACKUP_DEST]="@SERVER_ROOT@/servers/%i/backup"

# Variables set through the environment can never be overridden by config files.
declare -A environment_overrides
# Variables set through instance_config can be overridden by the instance config file, but not by the
# global configuration file.
declare -A instance_overrides

# Gather environment variables and make note of overrides.
for var in ${!default_config[@]}; do
	if [[ -v $var ]]; then
		echo "Configuration variable overridden by environment: ${var}=${!var}" >&2
		environment_overrides[$var]="${!var}"
		continue
	fi

	if [[ -v SERVER_INSTANCE && -v instance_config[$var] ]]; then
		instance_overrides[$var]="${instance_config[$var]//%i/${SERVER_INSTANCE}}"
	else
		declare $var="${default_config[$var]}"
	fi
done

# Variables passed over the command line will always override the one from a config file
if test -r "${CONFIG_PATH}"; then
	source "${CONFIG_PATH}" || (echo "Could not source ${CONFIG_PATH}" >&2)
fi

# Restore config variables that are always instance-specific.
for var in ${!instance_overrides[@]}; do
	declare $var="${instance_overrides[$var]}"
done

# Load the instance-specific configuration if it exists.
if [[ -v SERVER_INSTANCE ]]; then
	INSTANCE_CONFIG_PATH="${INSTANCE_CONFIG_DIR}/${SERVER_INSTANCE}"
	if test -r "${INSTANCE_CONFIG_PATH}"; then
		source "${INSTANCE_CONFIG_PATH}" || (echo "Could not source ${INSTANCE_CONFIG_PATH}" >&2)
	fi
fi

# Save the instance argument for launches of e.g. the idle server
INSTANCE_ARG=""
if [[ -v SERVER_INSTANCE ]]; then
	INSTANCE_ARG="--instance=${SERVER_INSTANCE}"
fi

# Expand macros in the config and set final values.
# These are set to readonly so they cannot be accidentally changed later.
for var in ${!default_config[@]}; do
	value="${environment_overrides[$var]:-${!var}}"
	for ivar in ${!default_config[@]} INAME GAME_USER; do
		value="${value//@$ivar@/${!ivar}}"
	done
	
	declare -r $var="$value"
done

# Exit if a single command breaks and its failure is not handled accordingly
set -e

MAX_SERVER_START_TIME=150

# Check whether sudo is needed at all
if [[ "$(whoami)" == "${GAME_USER}" ]]; then
	SUDO_CMD=""
else
	SUDO_CMD="sudo -u ${GAME_USER}"
fi

# We use an alternate tmux socket directory because tmux's default socket
# directory includes the uid. The systemd sandboxing uses a private /tmp,
# so to expose the tmux socket directory to the host we need to change to
# a socket path that uses the user id.
GAME_USER_UID=$(id -u ${GAME_USER})
LEGACY_TMUX_SOCKET_PATH="/tmp/tmux-${GAME_USER_UID}/${SESSION_NAME}"
TMUX_SOCKET_PATH="@TMUX_SOCKET_DIR@/${SESSION_NAME}"
# Look for the old socket path prior to version upgrade. If we find it,
# and there's nothing running on the new path yet, use the old path so we
# can still safely stop the old server, send commands, etc.
if [[ -S "${LEGACY_TMUX_SOCKET_PATH}" && ! -S "${TMUX_SOCKET_PATH}" ]]; then
	TMUX_CMD="${SUDO_CMD} tmux -S ${LEGACY_TMUX_SOCKET_PATH}"
else
	test -d `dirname "${TMUX_SOCKET_PATH}"` || mkdir -p `dirname "${TMUX_SOCKET_PATH}"`
	TMUX_CMD="${SUDO_CMD} tmux -S ${TMUX_SOCKET_PATH}"
fi

# Choose which flavor of netcat is to be used
if command -v netcat &> /dev/null; then
	NETCAT_CMD="netcat"
elif command -v ncat &> /dev/null; then
	NETCAT_CMD="ncat"
else
	NETCAT_CMD=""
fi

# Check for sudo rights
if [[ "${COMMAND}" != "print" ]]; then
	if [[ "$(${SUDO_CMD} whoami)" != "${GAME_USER}" ]]; then
		>&2 echo -e "You have \e[39;1mno permission\e[0m to run commands as $GAME_USER user."
		exit 21
	fi
fi

# Pipe any given argument to the game server console,
# sleep for $sleep_time and return its output if $return_stdout is set
game_command() {
	${TMUX_CMD} wait-for -L "command_lock"
	if [[ -z "${return_stdout:-}" ]]; then
		${TMUX_CMD} send-keys -t "${SESSION_NAME}":0.0 "$*" Enter
	else
		${TMUX_CMD} pipe-pane -t "${SESSION_NAME}":0.0 "cat > ${GAME_COMMAND_DUMP}"
		${TMUX_CMD} send-keys -t "${SESSION_NAME}":0.0 "$*" Enter
		sleep "${sleep_time:-0.3}"
		${TMUX_CMD} pipe-pane -t "${SESSION_NAME}":0.0
		${SUDO_CMD} cat "${GAME_COMMAND_DUMP}"
	fi
	${TMUX_CMD} wait-for -U "command_lock"
}

# Check whether there are player on the server through list
is_player_online() {
	response="$(sleep_time=0.6 return_stdout=true game_command list)"
	# Delete leading line and fancy characters from free response string
	response="$(echo "${response}" | sed -r -e 's/\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?[JKmsuG]//g')"
	# The list command prints a line containing the usernames after the last occurrence of ": "
	# and since playernames may not contain this string the clean player-list can easily be retrieved.
	# Otherwise check the first digit after the last occurrence of "There are". If it is 0 then there
	# are no players on the server. Should this test fail as well. Assume that a player is online.
	if [[ $(echo "${response}" | sed -n -r -e 's/.*\: ?//p' | tr -d '\n' | wc -c) -le 1 ]]; then
		# No player is online
		return 0
	elif [[ "x$(echo "${response}" | sed -n -r -e 's/.*there are[^0-9+]*([0-9]+).*$/\1/ip' | tr -d '\n')" == "x0" ]]; then
		# No player is online
		return 0
	else
		# A player is online (or it could not be determined)
		return 1
	fi
}

# Check whether the server is visited by a player otherwise shut it down
idle_server_daemon() {
	# This function is run within a tmux session of the GAME_USER therefore SUDO_CMD can be omitted
	if [[ "$(whoami)" != "${GAME_USER}" ]]; then
		>&2 echo "Somehow this hidden function was not executed by the ${GAME_USER} user."
		>&2 echo "This should not have happend. Are you messing around with this script? :P"
		exit 22
	fi

	# Time in seconds for which no player was on the server
	no_player=0

	while true; do
		printf "no_player: %10ss  check_player_time: %10ss  idle_if_time: %10ss\n" "${no_player}" "${CHECK_PLAYER_TIME}" "${IDLE_IF_TIME}"
		# Retry in ${CHECK_PLAYER_TIME} seconds
		sleep ${CHECK_PLAYER_TIME}

		if socket_has_session "${SESSION_NAME}"; then
			# Game server is up and running
			# Check for active player
			if [[ -n "$(${TMUX_CMD} list-clients -t "${SESSION_NAME}":0.0 2> /dev/null)" ]]; then
				# An administrator is connected to the console, pause player checking
				echo "An admin is connected to the console. Pause player checking."
			elif SUDO_CMD="" is_player_online; then
				# No player was seen on the server through list
				no_player=$(( no_player + CHECK_PLAYER_TIME ))
				# Stop the game server if no player was active for at least ${IDLE_IF_TIME}
				if [[ "${no_player}" -ge "${IDLE_IF_TIME}" ]]; then
					env IDLE_SERVER="false" ${INAME} ${INSTANCE_ARG} stop
					# Wait for game server to go down
					for i in {1..100}; do
						socket_has_session "${SESSION_NAME}" || break
						[[ $i -eq 100 ]] && echo -e "An \e[39;1merror\e[0m occurred while trying to reset the idle_server!"
						sleep 0.1
					done
					# Reset timer and give the player 300 seconds to connect after pinging
					no_player=$(( IDLE_IF_TIME - 300 ))
					# Game server is down, listen on port ${GAME_PORT} for incoming connections
					echo -n "Netcat: "
					${NETCAT_CMD} -v -l -p ${GAME_PORT} 2>&1 | (grep -m1 -i "connect" && pkill -P $$ ${NETCAT_CMD}) || true
					echo "Netcat caught a connection. The server is coming up again..."
					env IDLE_SERVER="false" ${INAME} ${INSTANCE_ARG} start
				fi
			else
				# Reset timer since there is an active player on the server
				no_player=0
			fi
		else
			# Reset timer and give the player 300 seconds to connect after pinging
			no_player=$(( IDLE_IF_TIME - 300 ))
			# Game server is down, listen on port ${GAME_PORT} for incoming connections
			echo -n "Netcat: "
			${NETCAT_CMD} -v -l -p ${GAME_PORT} 2>&1 | (grep -m1 -i "connect" && pkill -P $$ ${NETCAT_CMD}) || true
			echo "Netcat caught a connection. The server is coming up again..."
			env IDLE_SERVER="false" ${INAME} ${INSTANCE_ARG} start
		fi
	done
}

# Start the server if it is not already running
server_start() {
	# Start the game server
	if socket_has_session "${SESSION_NAME}"; then
		echo "A tmux ${SESSION_NAME} session is already running. Please close it first."
	else
		echo -en "Starting server..."
		${SUDO_CMD} rm -f "${GAME_COMMAND_DUMP}"
		# Use a plain file as command buffers for the server startup and switch to a FIFO pipe later
		${SUDO_CMD} touch "${GAME_COMMAND_DUMP}"
		# Ensure pipe-pine is started before the server itself by splitting the session creation and server startup
		${TMUX_CMD} new-session -s "${SESSION_NAME}" -c "${SERVER_ROOT}" -d /bin/bash
		# Mimic GNU screen and allow for both C-a and C-b as prefix
		${TMUX_CMD} set -g prefix2 C-a
		${TMUX_CMD} wait-for -L "command_lock"
		${TMUX_CMD} pipe-pane -t "${SESSION_NAME}":0.0 "cat > ${GAME_COMMAND_DUMP}"
		${TMUX_CMD} send-keys -t "${SESSION_NAME}":0.0 "exec ${SERVER_START_CMD}" Enter
		for ((i=1; i<=MAX_SERVER_START_TIME; i++)); do
			sleep "${sleep_time:-0.1}"
			if ! socket_session_is_alive "${SESSION_NAME}"; then
				echo -e "\e[39;1m failed\e[0m\n"
				>&2 ${SUDO_CMD} cat "${GAME_COMMAND_DUMP}"
				${SUDO_CMD} rm -f "${GAME_COMMAND_DUMP}"
				# Session is dead but remain-on-exit left it open; close it for sure
				${TMUX_CMD} kill-session -t "${SESSION_NAME}"
				exit 1
			elif grep -q -i "${SERVER_START_SUCCESS}" "${GAME_COMMAND_DUMP}"; then
				echo -e "\e[39;1m done\e[0m"
				break
			elif [[ $i -eq ${MAX_SERVER_START_TIME} ]]; then
				echo -e "\e[39;1m skipping\e[0m"
				>&2 echo -e "Server startup has not finished yet; continuing anyways"
			fi
		done
		${TMUX_CMD} pipe-pane -t "${SESSION_NAME}":0.0
		# Let the command buffer be a FIFO pipe
		${SUDO_CMD} rm -f "${GAME_COMMAND_DUMP}"
		${SUDO_CMD} mkfifo "${GAME_COMMAND_DUMP}"
		${TMUX_CMD} wait-for -U "command_lock"
	fi

	if [[ "${IDLE_SERVER,,}" == "true" ]]; then
		# Check for the availability of the netcat (nc) binaries
		if [[ -z "${NETCAT_CMD}" ]]; then
			>&2 echo "The netcat binaries are needed for suspending an idle server."
			exit 12
		fi

		# Start the idle server daemon
		if socket_has_session "${IDLE_SESSION_NAME}"; then
			${TMUX_CMD} kill-session -t "${IDLE_SESSION_NAME}"
			# Restart as soon as the idle_server_daemon has shut down completely
			for i in {1..100}; do
				sleep 0.1
				if ! socket_has_session "${IDLE_SESSION_NAME}"; then
					${TMUX_CMD} new-session -s "${IDLE_SESSION_NAME}" -d "${INAME} ${INSTANCE_ARG} idle_server_daemon"
					break
				fi
				[[ $i -eq 100 ]] && echo -e "An \e[39;1merror\e[0m occurred while trying to reset the idle_server!"
			done
		else
			echo -en "Starting idle server daemon..."
			${TMUX_CMD} new-session -s "${IDLE_SESSION_NAME}" -d "${INAME} ${INSTANCE_ARG} idle_server_daemon"
			echo -e "\e[39;1m done\e[0m"
		fi
	fi
}

# Stop the server gracefully by saving everything prior and warning the users
server_stop() {
	# Quit the idle daemon
	if [[ "${IDLE_SERVER,,}" == "true" ]]; then
		# Check for the availability of the netcat (nc) binaries
		if [[ -z "${NETCAT_CMD}" ]]; then
			>&2 echo "The netcat binaries are needed for suspending an idle server."
			exit 12
		fi

		if socket_has_session "${IDLE_SESSION_NAME}"; then
			echo -en "Stopping idle server daemon..."
			${TMUX_CMD} kill-session -t "${IDLE_SESSION_NAME}"
			echo -e "\e[39;1m done\e[0m"
		else
			echo "The corresponding tmux session for ${IDLE_SESSION_NAME} was already dead."
		fi
	fi

	# Gracefully exit the game server
	if socket_has_session "${SESSION_NAME}"; then
		# Game server is up and running, gracefully stop the server when there are still active players

		# Check for active player
		if is_player_online; then
			# No player was seen on the server through list
			echo -en "Server is going down..."
			game_command stop
		else
			# Player(s) were seen on the server through list (or an error occurred)
			# Warning the users through the server console
			game_command say "Server is going down in 10 seconds! HURRY UP WITH WHATEVER YOU ARE DOING!"
			game_command save-all
			echo -en "Server is going down in..."
			for i in {1..10}; do
				game_command say "down in... $(( 10 - i ))"
				echo -n " $(( 10 - i ))"
				sleep 1
			done
			game_command stop
		fi

		# Finish as soon as the server has shut down completely
		for i in {1..100}; do
			if ! socket_has_session "${SESSION_NAME}"; then
				${SUDO_CMD} rm -f "${GAME_COMMAND_DUMP}"
				echo -e "\e[39;1m done\e[0m"
				break
			fi
			[[ $i -eq 100 ]] && echo -e "\e[39;1m timed out\e[0m"
			sleep 0.1
		done
	else
		echo "The corresponding tmux session for ${SESSION_NAME} was already dead."
	fi
}

# Print whether the server is running and if so give some information about memory usage and threads
server_status() {
	# Print status information about the idle daemon
	if [[ "${IDLE_SERVER,,}" == "true" ]]; then
		# Check for the availability of the netcat (nc) binaries
		if [[ -z "${NETCAT_CMD}" ]]; then
			>&2 echo "The netcat binaries are needed for suspending an idle server."
			exit 12
		fi

		if socket_has_session "${IDLE_SESSION_NAME}"; then
			echo -e "Idle server daemon status:\e[39;1m running\e[0m"
		else
			echo -e "Idle server daemon status:\e[39;1m stopped\e[0m"
		fi
	fi

	# Print status information for the game server
	if socket_has_session "${SESSION_NAME}"; then
		echo -e "Status:\e[39;1m running\e[0m"

		# Calculating memory usage
		for p in $(${SUDO_CMD} pgrep -f "${MAIN_EXECUTABLE}"); do
			ps -p"${p}" -O rss | tail -n 1;
		done | gawk '{ count ++; sum += $2 }; END {count --; print "Number of processes =", count, "(tmux +", count, "x server)"; print "Total memory usage =", sum/1024, "MB" ;};'
	else
		echo -e "Status:\e[39;1m stopped\e[0m"
	fi
}

# Restart the complete server by shutting it down and starting it again
server_restart() {
	if socket_has_session "${SESSION_NAME}"; then
		server_stop
		server_start
	else
		server_start
	fi
}

# Backup the directories specified in BACKUP_PATHS
backup_files() {
	# Check for the availability of the tar binaries
	if ! command -v tar &> /dev/null; then
		>&2 echo "The tar binaries are needed for a backup."
		exit 11
	fi

	echo "Starting backup..."
	fname="$(date +%Y_%m_%d_%H.%M.%S).tar.gz"
	${SUDO_CMD} mkdir -p "${BACKUP_DEST}"
	if socket_has_session "${SESSION_NAME}"; then
		game_command save-off
		game_command save-all
		sleep "${sleep_time:-0.3}"
		sync && wait
		${SUDO_CMD} tar -C "${SERVER_ROOT}" -cf "${BACKUP_DEST}/${fname}" ${BACKUP_PATHS} --totals ${BACKUP_FLAGS} 2>&1 | grep -v "tar: Removing leading "
		game_command save-on
	else
		${SUDO_CMD} tar -C "${SERVER_ROOT}" -cf "${BACKUP_DEST}/${fname}" ${BACKUP_PATHS} --totals ${BACKUP_FLAGS} 2>&1 | grep -v "tar: Removing leading "
	fi
	echo -e "\e[39;1mbackup completed\e[0m\n"

	echo -n "Only keeping the last ${KEEP_BACKUPS} backups and removing the other ones..."
	backup_count=$(for f in "${BACKUP_DEST}"/[0-9_.]*; do echo "${f}"; done | wc -l)
	if [[ $(( backup_count - KEEP_BACKUPS )) -gt 0 ]]; then
		for old_backup in $(for f in "${BACKUP_DEST}"/[0-9_.]*; do echo "${f}"; done | head -n"$(( backup_count - KEEP_BACKUPS ))"); do
			${SUDO_CMD} rm "${old_backup}";
		done
		echo -e "\e[39;1m done\e[0m ($(( backup_count - KEEP_BACKUPS)) backup(s) pruned)"
	else
		echo -e "\e[39;1m done\e[0m (no backups pruned)"
	fi
}

# Restore backup
backup_restore() {
	# Check for the availability of the tar binaries
	if ! command -v tar &> /dev/null; then
		>&2 echo "The tar binaries are needed for a backup."
		exit 11
	fi

	# Only allow the user to restore a backup if the server is down
	if socket_has_session "${SESSION_NAME}"; then
		>&2 echo -e "The \e[39;1mserver should be down\e[0m in order to restore the world data."
		exit 3
	fi

	# Either let the user choose a backup or expect one as an argument
	if [[ $# -lt 1 ]]; then
		echo "Please enter the corresponding number for the backup to be restored: "
		i=1
		for f in "${BACKUP_DEST}"/[0-9_.]*; do
			echo -e "    \e[39;1m$i)\e[0m\t$f"
			i=$(( i + 1 ))
		done
		echo -en "Restore backup number: "

		# Read in user input
		read -r user_choice

		# Interpeting the input
		if [[ $user_choice =~ ^-?[0-9]+$ ]]; then
			n=1
			for f in "${BACKUP_DEST}"/[0-9_.]*; do
				[[ ${n} -eq $user_choice ]] && fname="$f"
				n=$(( n + 1 ))
			done
			if [[ -z $fname ]]; then
				>&2 echo -e "\e[39;1mFailed\e[0m to interpret your input. Please enter the digit of the presented options."
				exit 5
			fi
		else
			>&2 echo -e "\e[39;1mFailed\e[0m to interpret your input. Please enter a valid digit for one of the presented options."
			exit 6
		fi
	elif [[ $# -eq 1 ]]; then
		# Check for the existance of the specified file
		if [[ -f "$1" ]]; then
			fname="$1"
		else
			if [[ -f "${BACKUP_DEST}"/"$1" ]]; then
				fname="${BACKUP_DEST}"/"$1"
			else
				>&2 echo -e "Sorry, but '$1', is \e[39;1mnot a valid file\e[0m, neither in your current directory nor in the backup folder."
				exit 4
			fi
		fi
	elif [[ $# -gt 1 ]]; then
		>&2 echo -e "\e[39;1mToo many arguments.\e[0m Please pass only the filename for the world data as an argument."
		>&2 echo "Or alternatively, no arguments at all to choose from a list of available backups."
		exit 7
	fi

	echo "Restoring backup..."
	if ${SUDO_CMD} tar -xf "${fname}" -C "${SERVER_ROOT}" 2>&1; then
		echo -e "\e[39;1mRestoration completed\e[0m"
	else
		echo -e "\e[39;1mFailed to restore backup.\e[0m"
	fi
}

# Run the given command at the game server console
server_command() {
	if [[ $# -lt 1 ]]; then
		>&2 echo "No server command specified. Try 'help' for a list of commands."
		exit 1
	fi

	if socket_has_session "${SESSION_NAME}"; then
		return_stdout=true game_command "$@"
	else
		echo "There is no ${SESSION_NAME} session to connect to."
	fi
}

# Enter the tmux game session
server_console() {
	if socket_has_session "${SESSION_NAME}"; then
		${TMUX_CMD} attach -t "${SESSION_NAME}":0.0
	else
		echo "There is no ${SESSION_NAME} session to connect to."
	fi
}

# Check if there is a session available
socket_has_session() {
	if [[ "$(whoami)" != "${GAME_USER}" ]]; then
		${TMUX_CMD} has-session -t "${1}":0.0 2> /dev/null
		return $?
	fi
	${TMUX_CMD} -L "${SESSION_NAME}" has-session -t "${1}":0.0 2> /dev/null
	return $?
}

socket_session_is_alive() {
	if socket_has_session "${1}"; then
		if [[ "$(whoami)" != "${GAME_USER}" ]]; then
			return $(${TMUX_CMD} list-panes -t "${1}":0.0 -F '#{pane_dead}' 2> /dev/null)
		fi
		return $(${TMUX_CMD} list-panes -t "${1}":0.0 -F '#{pane_dead}' 2> /dev/null)
	else
		return 1
	fi
}

print_config() {
	if [[ -n "$1" ]]; then
		if [[ ! -v "default_config[$1]" ]]; then
			echo "$1 is not a recognized configuration variable." >&2
			return 1
		fi

		echo "${!1}"
	else
		(
			for var in ${!default_config[@]}; do
				echo "$var=${!var}"
			done
		) | sort
	fi
}

init_directories() {
	for dir in $SERVER_ROOT $BACKUP_DEST; do
		$SUDO_CMD install -D -d -m 0700 $dir
	done
}

case "$COMMAND" in
	start)
	server_start
	;;

	stop)
	server_stop
	;;

	status)
	server_status
	;;

	restart)
	server_restart
	;;

	console)
	server_console
	;;

	command)
	server_command "${SERVER_COMMAND}"
	;;

	backup)
	backup_files
	;;

	restore)
	backup_restore "${ARCHIVE_PATH}"
	;;

	print)
	print_config "${CONFIG_VAR:-}"
	;;

	init)
	init_directories
	;;

	idle_server_daemon)
	# This shall be a hidden function which should only be invoked internally
	idle_server_daemon
	;;
esac

exit 0
